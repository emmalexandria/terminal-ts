![terminal-ts logo](https://raw.githubusercontent.com/emmalexandria/terminal-ts/refs/heads/main/assets/wordmark.png)
# terminal-ts

`terminal-ts` is a library written in Typescript (but built to Javascript with `.dts` files) for creating fake terminal user interfaces on the web. 

**N.B: `terminal-ts` is currently in the very early stages. Every update will likely be breaking, and it is not yet intended for use in any form of anything approaching production.**

## Features
- Generates a virtual file system from a real file system on disk for your users to interact with
- Allows you to write and run commands
- Control output styling, rendering, etc in your project
- Outputs actual DOM elements
- Entirely framework agnostic

## Installation
`terminal-ts` can be installed from NPM with your favourite package manager:

`npm install terminal-ts`

## Usage

### VFS
To create a VFS:
1. Create a directory to be used to generate the virtual file system
2. Run `serverBuildVfsRoot` and make the result accessible (e.g. through an API endpoint)
3. Create a new `Vfs` class in the browser, passing in the object generated by the previous step.

Example in Astro:
```typescript
//src/pages/vfs.json.ts
import type { APIRoute } from "astro";
import { serverBuildVfsRoot } from "terminal-ts/vfs"

export const GET: APIRoute = async ({ params, request }) => {
  const vfsRoot = await serverBuildVfsRoot("./vfs");
  return new Response(
    JSON.stringify(vfsRoot)
  )
}

//Terminal.astro (component)
import {Vfs} from "terminal-ts/vfs"
const res = await fetch("/vfs.json");
const vfs = new Vfs(await res.json());
```

### Terminal
The terminal is created with a `Vfs`, an `OutputCallback`, a `PromptUpdateCallback` and a `PromptContentCallback`, and an optional startup command.
In addition, commands can be added to the `commands` field of `Terminal`.
The callbacks serve the following purposes:
1. `OutputCallback` — Called when the terminal has a new line of text to be appended to your terminal element
2. `PromptUpdateCallback` — Used to update your prompt if you are customising it extensively. Gets passed a `PromptUpdate`.
3. `PromptContentCallback` — Called by the terminal when a command is entered. Should return the way the prompt should be displayed in the terminal history.

Example in Astro:
```html
<div class="terminal-wrapper">
  <div class="terminal-border">
    <code class="terminal-buffer"></code>
    <div class="prompt-wrapper">
      <span class="prompt-info">~ </span><div contenteditable class="terminal-input"></div>
    </div>
  </div>
</div>
```

```typescript
import {Terminal,  type OutputCallback, type PromptUpdateCallback, type PromptContentCallback } from "terminal-ts/terminal";
import {Vfs} from "terminal-ts/vfs"
import {keyboardInputHandler} from "terminal-ts/handlers"
import {basicCommands} from "terminal-ts/commands";


const wrapper = document.querySelector(".terminal-wrapper") as HTMLDivElement;
const buffer: HTMLElement = document.querySelector(".terminal-buffer") as HTMLElement;
const inputEl = document.querySelector(".terminal-input") as HTMLDivElement;

const outputCallback: OutputCallback = (line) => {
  buffer.appendChild(line)
}

const promptUpdateCallback: PromptUpdateCallback = ({content, lastCommandSuccess, vfs, currentCommand}) => {
  if(content) {
    inputEl.textContent = content   
  }
}

const promptContentCallback: PromptContentCallback = () => {
  return "~ " + inputEl.textContent
  
}

const terminal = new Terminal(vfs, outputCallback, promptUpdateCallback, promptContentCallback, startupCommand)
terminal.commands.push(...basicCommands);

inputEl.addEventListener("keydown", (ev) => {
  keyboardInputHandler(ev, terminal, inputEl)
})
```

This code also uses two other pieces of functionality, being the `basicCommands`. This provides a set of commands pre-built for your use, such as `ls`, `cat`, and `cd`. It also uses 
`keyboardInputHandler`, which is a basic input handler for a `contenteditable` prompt. 

### Commands
Commands are very simple to define. They implement the following interface:
```typescript
export interface Command {
  name: string;
  description?: string;
  run: (terminal: Terminal, args: string[]) => void;
}
```

As an example of a simple command, here's the built-in `cat` command:
```typescript
export const Cat: Command = {
  name: "cat",
  description: "Print the contents of a file",
  run: (t, a) => {
    if (!a[0]) {
      throw new Error("Invalid arguments, please provide a file");
    }
    try {
      //Read the file with the Vfs readFile() method.
      const content = t.vfs.readFile(a[0]);
      t.print(content);
    } catch (e) {
      throw e;
    }
  },
};
```

Any errors thrown in a command will be caught by the terminal and printed as red error text.

## Planned features
- Terminal command history
- Cursor support, clearing, etc
- Image support

